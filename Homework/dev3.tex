\setcounter{part}{3}
\part{INFDEV02-3}
\setcounter{chapter}{0}
\chapter{Introduction to object-oriented programming}

    \section{Classes}
    
\subsection{Exercise 0}
            Translate the Python-program below to Java or C\#:
            \begin{lstlisting}
result = ""
for i in range(0,9):
    for j in range(0,i):
        result += "*"
    result += "\n"
print(result)
            \end{lstlisting}

\subsection{Exercise 1} Write a program that draws a smiley on the console (just like in INFDEV02-1).
\subsection{Exercise 2} Write an example of Python code that would cause a type error in Java/C\#
\subsection{Exercise 3} Make a static function that sums all numbers between two inputs read from the console and prints the result
\subsection{Exercise 4} Given all semantic and typing rules in the slides, write them down in plain English or Dutch
\subsection{Exercise 5} 
Make an \texttt{Interval} class that:
            \begin{itemize}
                \item takes two integers, \texttt{start} and \texttt{end}, as its constructor parameters
                \item has a \texttt{Sum} method that returns the sum of all numbers between \texttt{start} and \texttt{end}
                \item has a \texttt{Product} method that returns the product of all numbers between \texttt{start} and \texttt{end}
            \end{itemize}
\subsection{Exercise 6} 
Make a class \texttt{IntArrayOpperations} that:
            \begin{itemize}
                \item takes an array of integers, as its constructor parameter
                \item has a \texttt{Sum} method that returns the sum of all numbers in the array
                \item has a \texttt{Product} method that returns the product of all numbers in the array
            \end{itemize}

\subsection{Exercise 7} 
A \texttt{Counter} with the following body:
            \begin{itemize}
                \item With a \texttt{count} integer attribute;
                \item With an empty (parameterless) constructor;
                \item With a method \texttt{Reset};
                \item With a method \texttt{Tick};
                \item (\textbf{Advanced}) With a static method/overloaded operator \texttt{Plus} which adds two counters into one;
                \item (\textbf{Advanced}) With a method \texttt{OnTarget} that takes as input a lambda function which will be fired when the counter reaches a given count.
            \end{itemize}
            
\section{Arrays}
\subsection{Exercise 8}
Make a class \texttt{UserStory} that contains:
                \begin{itemize}
                    \item 2 variables:
                        \begin{itemize}
                            \item hours
                            \item description
                        \end{itemize}

                        \item getters and setters for the two variables variables
                        \item a ToString method
                \end{itemize}
\noindent
Moreover, in the main method instantiate 3 UserStory-objects.
\vspace{0.5cm}
\noindent
Write a class \texttt{Sprint} that contains:
                 \begin{itemize}
                    \item 1 variable: an array of UserStories
                    \item methods:
                    \begin{itemize}
                        \item TotalHours() which sums all the hours in the UserStories
                        \item a ToString method
                        \item AddUserStory which adds a UserStory to the array of Userstories
                \end{itemize}
            \end{itemize}
\noindent
Moreover, in the main method instantiate 3 UserStory-objects.        

\section{Constructors and Collections}
\subsection{Exercise 9}

     We will revisit the \texttt{UserStory}- and \texttt{Sprint}-classes and extend them.
     In this exercise you will apply knowledge about constructors, collections
         \begin{enumerate}
             \item To both classes add a constructor which sets their instance variables.
             \item In the \texttt{Sprint} class: Instead of an array, use an ArrayList or List to store UserStories.
             \item \texttt{Sprints} usually have a startdate (17th of february) and a duration (for example: 1 week). Add these variables to the class. Try and google which datatypes (classes) are suitable for storing dates and durations.
             \item Also, add getters for the previous variables and update the constructor.
             \item \texttt{UserStories} have to store their status: Todo, In progress, To verify, Done. Add a variable that can store this.
             \item Write methods in the \texttt{Sprint}-class that:
             \begin{itemize}
                  \item returns the amount of hours of work still to be done in a sprint.
                  \item returns the amount of hours already done in a sprint.
                  \item returns if the current sprint is done
             \end{itemize}
             \item (Optional) The datatype you chose for the status (Todo, Done, etc.) is probably a String, right? Readup\footnote{\href{https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html}{https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html}} on Enums, a special type and use an enum to store the status.
         \end{enumerate}


\chapter{Reuse through polymorphism}

    \section{Interfaces}	    
		\subsection{Exercise 0}
	    \begin{itemize}
	    	\item Define an interface \texttt{Animal} with at least one method \texttt{SaySomething} that takes no arguments and returns \texttt{void}
	    	\item Define a \texttt{Cat} class that implements \texttt{Animal}. A cat prints on the console \texttt{Miao...} when \texttt{SaySomething} is called
	    	\item Define a \texttt{Dog} class that implements \texttt{Animal}. A dog prints on the console \texttt{Bao...} when \texttt{SaySomething} is called
	    	\item Define a \texttt{Cow} class that implements \texttt{Animal}. A cow prints on the console \texttt{Muuu...} when \texttt{SaySomething} is called
	    	\item[] Test your program with the following codes:
	    	\item The following code \texttt{Animal animal1 = new Cat(); animal1.SaySomething();} should print \texttt{Miao...}
	    	\item The following code \texttt{Animal animal2 = new Dog(); animal2.SaySomething();} should print \texttt{Bao...}
	    	\item The following code \texttt{Animal animal3 = new Cow(); animal3.SaySomething();} should print \texttt{Muuu...}
	    \end{itemize}
	    
    	\subsection{Exercise 1}
    	\begin{itemize}
    		\item Make a \texttt{Person} interface with methods (or properties with only a getter):
    		\begin{itemize}
    			\item Name
    			\item Surname
    			\item Age
    		\end{itemize}
    		
    		\item Make the \texttt{Customer}, \texttt{Student}, \texttt{Teacher} implementations of \texttt{Person}, ensuring that they all get at least three additional methods and attributes over those in \texttt{Person}
    	\end{itemize}
    	
	    \subsection{Exercise 2}
	        \begin{itemize}
	            \item Write a \texttt{Vehicle} interface with a method \texttt{move} and a method \texttt{loadFuel}; \texttt{loadFuel} accepts a \texttt{Fuel} instance, where \texttt{Fuel} is an interface of your writing; \texttt{move} returns a boolean which is \texttt{true} if there is enough fuel, and \texttt{false} otherwise
	            \item Write a concrete class \texttt{Car} and a concrete class \texttt{Gasoline} that implement, respectively, \texttt{Vehicle} and \texttt{Fuel}; the \texttt{Car} checks that the given fuel is indeed \texttt{Gasoline}
	            \item Write a concrete class \texttt{Truck} and a concrete class \texttt{Diesel} that implement, respectively, \texttt{Vehicle} and \texttt{Fuel}; the \texttt{Truck} checks that the given fuel is indeed \texttt{Diesel}
	            \item Write a concrete class \texttt{Enterprise} and a concrete class \texttt{Dilithium} that implement, respectively, \texttt{Vehicle} and \texttt{Fuel}; the \texttt{Enterprise} checks that the given fuel is indeed \texttt{Dilithium}
	            \item Make a program that receives three vehicles, without knowing their concrete type, and moves them (without resorting to conversions) until their fuel is up
	        \end{itemize}

	        
	 \subsection{Exercise 3}
	    \begin{itemize}
   	    	\item Make a \texttt{ListInt} interface with methods \texttt{Length}, \texttt{Iterate}, \texttt{Map}, \texttt{Filter}, and properties (read-only) IsEmpty
   	    	\item Define the concrete classes \texttt{NodeInt} and \texttt{EmptyInt} both implementing \texttt{ListInt}
   	    	\item (\textbf{Advanced}) Make a \texttt{ListInt}, fill it with a series of numbers, increment them all by one (hint: use \texttt{Map}), and print them all on the screen (hint: use \texttt{Iterate})
	    \end{itemize}     
	    
     \subsection{Exercise 4}
     \label{chapter: Reuse through polymorphism}     
     	 \textbf{Basic:}

	     \begin{itemize}
	     	\item Write an \texttt{IStateMachine} interface with a method \texttt{Update} and attribute \texttt{Done}, where \texttt{Update} takes a \texttt{float} number and returns \texttt{void}, and \texttt{Done} is read-only and of type \texttt{bool}
	     	\item Write a concrete class \texttt{Wait} that implements \texttt{IStateMachine}; A \texttt{Wait} takes an initial time when instantiated and at every update it decreases such amount until it gets all consumed. When the time is totally consumed \texttt{Done} becomes \texttt{true}
		    \item Write a concrete class \texttt{Print} that implements \texttt{IStateMachine}; A \texttt{Print} takes an initial message when instantiated and after the first update it prints the message and sets \texttt{Done} to \texttt{true}
		    \item Write a concrete class \texttt{Sequence} that implements \texttt{IStateMachine}; A \texttt{Sequence} takes two \texttt{IStateMachine} objects when instantiated and it keeps updating the first state machine until done before start updating the second state machine. \texttt{Done} is set to true when both state machines are done  
		    \item Test your program with the following code \texttt{new Sequence(new Wait(10), new Print("Hello World"))}. Make sure that it prints "Hello World" after 10 seconds. For this homework use MonoGame so to get the elapsed time for each update call.
	     \end{itemize}

	     \textbf{Advanced:}

	     \begin{itemize}
	     	\item Extend the \texttt{IStateMachine} interface with a new method \texttt{Reset} that takes no arguments and returns \texttt{void}.
	     	\item Make a \texttt{Repeat} class that implements \texttt{IStateMachine}; A \texttt{Repeat} takes a state machine when instantiated and at every update it keeps updating the given state machine until it is done. When the given state machine is done it gets reset, so its behavior can start all over again. The {Done} attribute of \texttt{Repeat} is always \texttt{false}
	     	\item Test your program with the following code \texttt{new Repeat(new Sequence(new Wait(10), new Print("Hello World")))} . Make sure that it prints "Hello World" every 10 seconds, \textit{forever}. For this homework use MonoGame so to get the elapsed time for each update call.
	     \end{itemize}



\begin{comment}
\chapter{Reuse through generics}
    \section{Exercise 1}
        \begin{itemize}
            
            \item (\textbf{Advanced}) Make a \texttt{List<T>} interface with methods \texttt{Length}, \texttt{Iterate}, \texttt{Map}, and \texttt{Filter}
            \item (\textbf{Advanced}) Define the concrete classes \texttt{Node<T>} and \texttt{Empty<T>} both implementing \texttt{List<T>}
            \item (\textbf{Advanced}) Make a \texttt{List<Vehicle>}, fill it with a series of concrete vehicles, and make them all move ten times
            \item Make a generic \texttt{Number<N>} abstract class, with methods:
            \begin{itemize}
                \item \texttt{Zero} that returns an \texttt{N}
                \item \texttt{One} that returns an \texttt{N}
                \item abstract methods \texttt{Negate}, that takes an \texttt{N} and returns an \texttt{N} (for example \texttt{Negate(1)} return \texttt{-1})
                - Plus, Times, DividedBy that all take two N's and returns an N
                \item The non-abstract method \texttt{Minus} that makes use of \texttt{Plus} and \texttt{Negate}
                \item abstract methods \texttt{SmallerThan} and \texttt{Equal}, that take two \texttt{N}'s and return a \texttt{boolean}
                \item The non-abstract methods \texttt{SmallerOrEqual}, \texttt{GreaterThan}, \texttt{GreaterOrEqual}, \texttt{NotEqual}
            \end{itemize}

            \item Make a class \texttt{IntNumber} that implements \texttt{Number<int>}
            \item Make a class \texttt{FloatNumber} that implements \texttt{Number<float>}
            \item Try to make a class \texttt{StringNumber} that implements \texttt{Number<string}: how far can you come?

            \item Make the \texttt{Interval} class we have seen in the first homework of DEV3 generic with respect to the type of the parameters \texttt{l} and \texttt{u}; specifically, build a generic class \texttt{Interval<N>} which takes as input two \texttt{N}'s \texttt{l} and \texttt{u}, and also an instance of \texttt{Number<N>}
        \end{itemize}
    \section{Exercise 2 - \small based on Chapter \ref{chapter: Reuse through polymorphism}}
	     \begin{myprop}
         \begin{itemize}
         	\item Write an \texttt{IAction<T>} parametric interface with a method \texttt{Invoke} that takes no arguments number and returns an object belonging to the type of the \texttt{T} (the parameter of the interface)
         	\item Write a \texttt{When} class that implements \texttt{IStateMachine}; A \texttt{When} takes an \texttt{IAction} of type \texttt{bool} (\texttt{IAction<bool>}) when instantiated and at every update it tries to invoke the given \texttt{IAction} and only if it returns \texttt{true} then set \texttt{Done} to \texttt{true}
         	\item Test your program with the following code \texttt{new Sequence(new When(}\\ \texttt{myRandom), new Run(new Print("Hello World")))}. Make sure that it prints "Hello World" after a random time. For this homework use MonoGame so to get the elapsed time for each update call. \texttt{myRandom} is an instance of the following class:
\begin{lstlisting}         	
pulic class MyRandom : IAction<bool>{
  Random seed = new System.Random();
  public bool Invoke(){ 
    return seed.Random().Next(10) > 7; 
  }
}
\end{lstlisting}
		\end{itemize}
	     \end{myprop}
         	
\end{comment}


\chapter{Architectural and design considerations}
    \section{Exercises}

        \begin{itemize}
            \item Write an \texttt{Event} abstract class or interface with a method \texttt{perform};
            \item Write a \texttt{Timer} class with a method \texttt{tick} and a method \texttt{reset}; \texttt{reset} restarts the timer, while \texttt{tick} makes the timer move forward and returns whether or not the target time has been reached; when the timer reaches the target time, then fire the events in the list of timer responses
            \item Make a \texttt{TrafficLight} class which uses timers to implement red, green, and yellow lights;
            \item (\textbf{Advanced}) Rebuild timers, but this time with lambda's instead of our custom \texttt{Event}.
            \item (\textbf{Advanced}) Make a \texttt{Component} interface;
            \item (\textbf{Advanced}) Make an \texttt{Entity} abstract class which houses a list of components;
            \item (\textbf{Advanced}) Write a \texttt{Car} class that inherits from \texttt{Entity} and which implements all the functionality that you would expect from a car, but with the \textit{Entity-Component} model; you will need to build components for the engine, the wheels, etc. and all that the \texttt{Car} class does is make correct use of these components.
        \end{itemize}

        \textbf{No reference solution yet:}
        \begin{itemize}
            \item Build an entity-component system where a \texttt{Person} is made up of multiple components such as shoes, clothes, make-up, personality, and intelligence (all implemented via appropriate interfaces); the \texttt{Person} then performs a few actions, such as doing sports, studying, and socializing through methods: the results of these actions depend on the components of the person so that, for example, doing sports with elegant shoes will have unpleasant results.
        \end{itemize}

